#pragma once

#include "c-typedesc.h"


#ifdef __cplusplus
extern "C" {
#else
#include <stdbool.h>
#endif

typedef struct OIIO_ImageInput OIIO_ImageInput;

typedef struct {
    int xbegin;
    int xend;
    int ybegin;
    int yend;
    int zbegin;
    int zend;
    int chbegin;
    int chend;
} OIIO_ROI;

typedef struct OIIO_ImageSpec OIIO_ImageSpec;

enum OIIO_ImageSpec_SerialVerbose {
    OIIO_ImageSpec_SerialVerbose_SerialBrief = 0,
    OIIO_ImageSpec_SerialVerbose_SerialDetailed = 1,
    OIIO_ImageSpec_SerialVerbose_SerialDetailedHuman = 2,
};

enum OIIO_ImageSpec_SerialFormat {
    OIIO_ImageSpec_SerialFormat_SerialText = 0,
    OIIO_ImageSpec_SerialFormat_SerialXML = 1,
};


/// Get the named global attribute of OpenImageIO, store it in `*val`.
/// Return `true` if found and it was compatible with the type specified,
/// otherwise return `false` and do not modify the contents of `*val`.  It
/// is up to the caller to ensure that `val` points to the right kind and
/// size of storage for the given type.
///
/// In addition to being able to retrieve all the attributes that are
/// documented as settable by the `OIIO::attribute()` call, `getattribute()`
/// can also retrieve the following read-only attributes:
///
/// - `string format_list`
/// - `string input_format_list`
/// - `string output_format_list`
///
///   A comma-separated list of all the names of, respectively, all
///   supported image formats, all formats accepted as inputs, and all
///   formats accepted as outputs.
///
/// - `string extension_list`
///
///   For each format, the format name, followed by a colon, followed by a
///   comma-separated list of all extensions that are presumed to be used
///   for that format.  Semicolons separate the lists for formats.  For
///   example,
///
///        "tiff:tif;jpeg:jpg,jpeg;openexr:exr"
///
/// - `string library_list`
///
///   For each format that uses a dependent library, the format name,
///   followed by a colon, followed by the name and version of the
///   dependency. Semicolons separate the lists for formats.  For example,
///
///        "tiff:LIBTIFF 4.0.4;gif:gif_lib 4.2.3;openexr:OpenEXR 2.2.0"
///
/// - string "timing_report"
///         A string containing the report of all the log_times.
///
/// - `string hw:simd`
/// - `string oiio:simd` (read-only)
///
///   A comma-separated list of hardware CPU features for SIMD (and some
///   other things). The `"oiio:simd"` attribute is similarly a list of
///   which features this build of OIIO was compiled to support.
///
///   This was added in OpenImageIO 1.8.
///
/// - `float resident_memory_used_MB`
///
///   This read-only attribute can be used for debugging purposes to report
///   the approximate process memory used (resident) by the application, in
///   MB.
///
/// - `string timing_report`
///
///    Retrieving this attribute returns the timing report generated by the
///    `log_timing` attribute (if it was enabled). The report is sorted
///    alphabetically and for each named instrumentation region, prints the
///    number of times it executed, the total runtime, and the average per
///    call, like this:
///
///        IBA::computePixelStats        2   2.69ms  (avg   1.34ms)
///        IBA::make_texture             1  74.05ms  (avg  74.05ms)
///        IBA::mul                      8   2.42ms  (avg   0.30ms)
///        IBA::over                    10  23.82ms  (avg   2.38ms)
///        IBA::resize                  20   0.24s   (avg  12.18ms)
///        IBA::zero                     8   0.66ms  (avg   0.08ms)
///
bool  OIIO_getattribute(const char* name, OIIO_TypeDesc type, void* val);

/// Union of two regions, the smallest region containing both.
OIIO_ROI  OIIO_roi_union(const OIIO_ROI* A, const OIIO_ROI* B);

/// Intersection of two regions.
OIIO_ROI  OIIO_roi_intersection(const OIIO_ROI* A, const OIIO_ROI* B);


OIIO_ImageInput*  OIIO_ImageInput_assign(OIIO_ImageInput* self, const OIIO_ImageInput* other);

/// Return the name of the format implemented by this class.
const char*  OIIO_ImageInput_format_name(const OIIO_ImageInput* self);


OIIO_ImageInput* OIIO_ImageInput_copy(const OIIO_ImageInput* other);

/// All() is an alias for the default constructor, which indicates that
/// it means "all" of the image, or no region restriction.  For example,
///     float myfunc (ImageBuf &buf, ROI roi = ROI::All());
/// Note that this is equivalent to:
///     float myfunc (ImageBuf &buf, ROI roi = {});
OIIO_ROI  OIIO_ROI_All();

/// Total number of pixels in the region.
unsigned long  OIIO_ROI_npixels(const OIIO_ROI* self);

/// Default constructor is an undefined region. Note that this is also
/// interpreted as All().
void  OIIO_ROI_default(OIIO_ROI* self);

/// Number of channels in the region.  Beware -- this defaults to a
/// huge number, and to be meaningful you must consider
/// std::min (imagebuf.nchannels(), roi.nchannels()).
int  OIIO_ROI_nchannels(const OIIO_ROI* self);

///@{
/// @name Spatial size functions.
/// The width, height, and depth of the region.
int  OIIO_ROI_width(const OIIO_ROI* self);


int  OIIO_ROI_height(const OIIO_ROI* self);

/// Is a region defined?
bool  OIIO_ROI_defined(const OIIO_ROI* self);


int  OIIO_ROI_depth(const OIIO_ROI* self);


OIIO_ImageSpec* OIIO_ImageSpec_copy(const OIIO_ImageSpec* other);

/// Returns, as a string, a serialized version of the `ImageSpec`. The
/// `format` may be either `ImageSpec::SerialText` or
/// `ImageSpec::SerialXML`. The `verbose` argument may be one of:
/// `ImageSpec::SerialBrief` (just resolution and other vital
/// statistics, one line for `SerialText`, `ImageSpec::SerialDetailed`
/// (contains all metadata in original form), or
/// `ImageSpec::SerialDetailedHuman` (contains all metadata, in many
/// cases with human-readable explanation).
void OIIO_ImageSpec_serialize(const OIIO_ImageSpec* self, int format, int verbose, char* _result_buffer_ptr, int _result_buffer_len);

/// Adjust the stride values, if set to AutoStride, to be the right
/// sizes for contiguous data with the given format, channels,
/// width, height.
void  OIIO_ImageSpec_auto_stride(long* xstride, long* ystride, long* zstride, long channelsize, int nchannels, int width, int height);

/// Constructs an `ImageSpec` with the given x and y resolution, number
/// of channels, and pixel data format.
///
/// All other fields are set to the obvious defaults -- the image is an
/// ordinary 2D image (not a volume), the image is not offset or a crop
/// of a bigger image, the image is scanline-oriented (not tiled),
/// channel names are "R", "G", "B"' and "A" (up to and including 4
/// channels, beyond that they are named "channel *n*"), the fourth
/// channel (if it exists) is assumed to be alpha.
OIIO_ImageSpec* OIIO_ImageSpec_new_with_dimensions(int xres, int yres, int nchans, OIIO_TypeDesc fmt);

/// Returns the number of bytes comprising each channel of each pixel
/// (i.e., the size of a single value of the type described by the
/// `format` field).
unsigned long  OIIO_ImageSpec_channel_bytes(const OIIO_ImageSpec* self);

/// Returns the number of bytes comprising each scanline, i.e.,
/// `pixel_bytes(native) * width` This will return
/// `std::numeric_limits<imagesize_t>::max()` in the event of an
/// overflow where it's not representable in an `imagesize_t`.
unsigned long  OIIO_ImageSpec_scanline_bytes(const OIIO_ImageSpec* self, bool native);

/// Constructor: given just the data format, set all other fields to
/// something reasonable.
OIIO_ImageSpec* OIIO_ImageSpec_new(OIIO_TypeDesc format);

/// Sets the `channelnames` to reasonable defaults for the number of
/// channels.  Specifically, channel names are set to "R", "G", "B,"
/// and "A" (up to and including 4 channels, beyond that they are named
/// "channel*n*".
void  OIIO_ImageSpec_default_channel_names(OIIO_ImageSpec* self);


OIIO_ImageSpec*  OIIO_ImageSpec_assign(OIIO_ImageSpec* self, const OIIO_ImageSpec* other);

/// Set the data format, and clear any per-channel format information
/// in `channelformats`.
void  OIIO_ImageSpec_set_format(OIIO_ImageSpec* self, OIIO_TypeDesc fmt);

/// Add a metadata attribute to `extra_attribs`, with the given name and
/// data type. The `value` pointer specifies the address of the data to
/// be copied.
void  OIIO_ImageSpec_attribute(OIIO_ImageSpec* self, const char* name, OIIO_TypeDesc type, const void* value);

/// Return the number of bytes needed for the single specified
/// channel.  If native is false (default), compute the size of one
/// channel of `this->format`, but if native is true, compute the size
/// of the channel in terms of the "native" data format of that
/// channel as stored in the file.
unsigned long  OIIO_ImageSpec_channel_bytes_for(const OIIO_ImageSpec* self, int chan, bool native);


#ifdef __cplusplus
}
#endif
    